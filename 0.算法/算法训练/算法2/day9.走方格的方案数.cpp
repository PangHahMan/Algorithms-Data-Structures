/* 描述
请计算n*m的棋盘格子（n为横向的格子数，m为竖向的格子数）从棋盘左上角出发沿着边缘线从左上角走到右下角，总共有多少种走法，要求不能走回头路，即：只能往右和往下走，不能往左和往上走。
 
输入描述：输入两个正整数n和m，用空格隔开。(1≤n,m≤8)

输出描述：输出一行结果

示例1
输入：2 2

输出：6
*/

/* 思路：
本题为求取路径总数的题目，一般可以通过递归求解，对于复杂的问题，可以通过动态规划求解。此题比较
简单，可以通过递归解答。 
| 1 | 2 | 3 |
-------------
| 4 | 5 | 6 |
-------------
| 7 | 8 | 9 |
-------------
1. 对于上面的n*m(3*3)的格子，有两种情况
a. 如果n或者m为1，则只有一行或者一列，从左上角走到右下角的路径数为n + m
比如： 1 * 1格子，可以先向下走，再向右走，到达右下角；或者先向右走，
再向下走，到达右下角，共两条，即 1 + 1 = 2，对于1 * m和 n * m的
情况同学们自己画一下
b. 如果n,m都大于1，那么走到[n][m]格子的右下角只有两条路径，
<1>: 从[n - 1][m]格子的右下角向下走，到达
<2>: 从[n][m - 1]格子的右下角向右走，到达
所以走到[n][m]格子的右下角的数量为[n-1][m] + [n][m - 1],可以通过递归实现，情况a为递归的终止条件。
*/

//方法1:动态规划
#include <iostream>
using namespace std;

int main() {
    int n, m;
    cin >> n >> m;

    // 定义二维数组dp，初始值全为0
    int dp[9][9] = {0};

    // 初始化第一行和第一列的走法数
    for (int i = 0; i <= n; i++)
        dp[i][0] = 1;
    for (int i = 0; i <= m; i++)
        dp[0][i] = 1;

    // 计算其余格子的走法数
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }

    // 输出结果
    cout << dp[n][m] << endl;

    return 0;
}

//方法2：递归
int pathnum(int n, int m) {
    if (n == 0 || m == 0) {
        return 1;
    }

    return pathnum(n - 1, m) + pathnum(n, m - 1);
}

int main() {
    int n, m;
    while (cin >> n >> m) {
        cout << pathnum(n, m) << endl;
    }
    return 0;
}