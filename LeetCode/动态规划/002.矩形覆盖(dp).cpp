/* 描述
我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，从同一个方向看总共有多少种不同的方法？  2*1 表示长和宽
*/

/* 
边界状态是：
f(0) = 0 （没有小矩形时，无法覆盖大矩形）
f(1) = 1 （只有一个小矩形时，只有一种覆盖方法）
f(2) = 2 （有两个小矩形时，有两种覆盖方法：两个竖着放或者两个横着放）

假设我们有n个2*1的小矩形用来覆盖一个2*n的大矩形，我们有两种基本的选项：

把第n个小矩形竖着放（占据大矩形的最后一列）。这样，我们就需要找出用剩下的n-1个小矩形覆盖剩下的2*(n-1)的大矩形的方法，即f(n-1)。

把第n和n-1个小矩形横着放（占据大矩形的最后两列）。这样，我们就需要找出用剩下的n-2个小矩形覆盖剩下的2*(n-2)的大矩形的方法，即f(n-2)。

由于上述两种放置方法是互斥的（即我们不能同时选择竖着放和横着放），所以我们可以把这两种可能性的总数加起来，得到所有可能的覆盖方法。因此f(n) = f(n-1) + f(n-2)。
 */
class Solution {
public:
    int rectCover(int number) {
        if (number == 1 || number == 0) {
            return number;
        }

        int *dp = new int[number + 1];
        dp[1] = 1;
        dp[2] = 2;

        for (int i = 3; i <= number; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        int num = dp[number];
        delete[] dp;

        return num;
    }
};

//https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?